<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Billboard Left/Right Consistency Verification</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #000;
            color: #00ffcc;
            font-family: Arial, sans-serif;
        }
        #info {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 100;
            color: #00ffcc;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 5px;
            max-width: 600px;
            border: 1px solid #00ffcc;
            max-height: 80vh;
            overflow-y: auto;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
        .test-result {
            margin: 8px 0;
            padding: 8px;
            border-radius: 3px;
            font-size: 13px;
        }
        .pass { background: rgba(0, 255, 0, 0.2); border-left: 3px solid #00ff00; }
        .fail { background: rgba(255, 0, 0, 0.2); border-left: 3px solid #ff0000; }
        .warn { background: rgba(255, 170, 0, 0.2); border-left: 3px solid #ffaa00; }
        .info { background: rgba(0, 255, 204, 0.1); border-left: 3px solid #00ffcc; }
        .summary { 
            background: rgba(255, 255, 255, 0.1); 
            border: 2px solid #00ffcc; 
            margin: 15px 0; 
            padding: 10px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="info">
        <h3>Billboard Left/Right Consistency Verification</h3>
        <p>This test specifically checks for any inconsistencies between left and right halves of billboard content.</p>
        <div id="test-results"></div>
        <p><strong>Controls:</strong> SPACE: Next test | R: Reset camera | A: Auto-run all tests</p>
    </div>
    
    <div id="container"></div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.158.0';
        
        const CONFIG = {
            BILLBOARD: {
                SCREEN_WIDTH: 512,
                SCREEN_HEIGHT: 256,
                PATTERN_TYPES: ['scrollText', 'pulse', 'wave', 'matrix'],
                MESSAGES: [
                    'TESTING LEFT RIGHT CONSISTENCY ACROSS FULL BILLBOARD WIDTH',
                    'THIS MESSAGE SHOULD APPEAR UNIFIED WITHOUT SPLITS OR BREAKS',
                    '<<< LEFT SIDE --- CENTER --- RIGHT SIDE >>>',
                    'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789',
                    'NO DISCONTINUITY SHOULD BE VISIBLE ANYWHERE'
                ],
                TEXT_SCROLL_SPEED: 1.5,
                PULSE_SPEED: 2,
                FADE_SPEED: 1
            }
        };

        let scene, camera, renderer, billboard, animationData;
        let testResults = [];
        let currentTestIndex = 0;
        let animationTime = 0;
        let frameCount = 0;

        // Specific tests for left/right consistency
        const consistencyTests = [
            {
                name: "Long Text Spanning Test",
                type: "scrollText",
                message: "LEFT-SIDE-TEXT-FLOWING-TO-CENTER-AND-CONTINUING-TO-RIGHT-SIDE-WITHOUT-BREAKS",
                duration: 8000,
                checkFunction: checkTextContinuity
            },
            {
                name: "Character Distribution Test", 
                type: "wave",
                message: "ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%^&*()",
                duration: 6000,
                checkFunction: checkCharacterDistribution
            },
            {
                name: "Uniform Pulse Test",
                type: "pulse", 
                message: "UNIFORM SCALING ACROSS ENTIRE SURFACE",
                duration: 5000,
                checkFunction: checkUniformPulse
            },
            {
                name: "Matrix Pattern Test",
                type: "matrix",
                message: "MATRIX BACKGROUND TEST",
                duration: 4000,
                checkFunction: checkMatrixUniformity
            },
            {
                name: "Edge Boundary Test",
                type: "scrollText",
                message: "|||EDGE|||CENTER|||EDGE|||",
                duration: 6000,
                checkFunction: checkEdgeBoundaries
            }
        ];

        function init() {
            setupScene();
            createTestBillboard();
            setupEventListeners();
            
            log("Left/Right consistency verification initialized", "info");
            startTest(0);
            animate();
        }

        function setupScene() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000011);
            document.getElementById('container').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0x404040, 1.0);
            scene.add(ambientLight);

            camera.position.set(0, 0, 8);
            camera.lookAt(0, 0, 0);
        }

        function createTestBillboard() {
            const group = new THREE.Group();
            
            // Frame
            const frameGeometry = new THREE.BoxGeometry(3.4, 2.4, 0.1);
            const frameMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x333333,
                transparent: true,
                opacity: 0.8
            });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            group.add(frame);

            // Screen with exact game implementation
            const screenGeometry = new THREE.PlaneGeometry(3.2, 2.2);
            
            // Critical: Use exact same UV mapping as game
            const uvs = new Float32Array([
                0, 1,  // bottom-left
                1, 1,  // bottom-right  
                1, 0,  // top-right
                0, 0   // top-left
            ]);
            screenGeometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));

            // Canvas texture
            const canvas = document.createElement('canvas');
            canvas.width = CONFIG.BILLBOARD.SCREEN_WIDTH;
            canvas.height = CONFIG.BILLBOARD.SCREEN_HEIGHT;
            const context = canvas.getContext('2d');
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.wrapS = THREE.ClampToEdgeWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;

            const screenMaterial = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                side: THREE.DoubleSide
            });

            const screen = new THREE.Mesh(screenGeometry, screenMaterial);
            screen.position.z = 0.06;
            group.add(screen);

            animationData = {
                screen,
                texture,
                canvas,
                context,
                material: screenMaterial,
                type: 'scrollText',
                phase: 0,
                message: 'INITIAL TEST MESSAGE',
                scrollOffset: 0,
                lastUpdate: 0
            };

            billboard = group;
            scene.add(billboard);
            
            log("Test billboard created with exact game implementation", "info");
        }

        function startTest(testIndex) {
            if (testIndex >= consistencyTests.length) {
                generateFinalReport();
                return;
            }

            currentTestIndex = testIndex;
            const test = consistencyTests[testIndex];
            
            // Reset animation data
            animationData.type = test.type;
            animationData.message = test.message;
            animationData.scrollOffset = 0;
            animationData.phase = 0;
            frameCount = 0;
            
            log(`\n=== STARTING TEST ${testIndex + 1}/${consistencyTests.length} ===`, "info");
            log(`Test: ${test.name}`, "info");
            log(`Animation: ${test.type}`, "info");
            log(`Message: "${test.message}"`, "info");
            log(`Duration: ${test.duration}ms`, "info");
            
            // Run test for specified duration
            setTimeout(() => {
                log(`\n--- ANALYZING TEST ${testIndex + 1} ---`, "info");
                test.checkFunction(test);
                
                // Auto-advance to next test
                setTimeout(() => {
                    startTest(testIndex + 1);
                }, 2000);
            }, test.duration);
        }

        function renderBillboardContent() {
            const { canvas, context, type, phase, message, texture } = animationData;
            const time = animationTime + phase;
            
            // Clear canvas
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = '#000011';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.font = 'bold 32px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            switch (type) {
                case 'scrollText':
                    renderScrollingText(time);
                    break;
                case 'pulse':
                    renderPulseText(time);
                    break;
                case 'wave':
                    renderWaveText(time);
                    break;
                case 'matrix':
                    renderMatrixEffect(time);
                    break;
            }
            
            texture.needsUpdate = true;
        }

        function renderScrollingText(time) {
            const { canvas, context, message } = animationData;
            
            animationData.scrollOffset += CONFIG.BILLBOARD.TEXT_SCROLL_SPEED;
            if (animationData.scrollOffset > canvas.width + 300) {
                animationData.scrollOffset = -300;
            }
            
            context.shadowColor = '#00ffcc';
            context.shadowBlur = 20;
            context.fillStyle = '#00ffcc';
            
            context.fillText(message, animationData.scrollOffset, canvas.height / 2);
            context.shadowBlur = 0;
        }

        function renderPulseText(time) {
            const { canvas, context, message } = animationData;
            
            const pulse = Math.sin(time * CONFIG.BILLBOARD.PULSE_SPEED) * 0.5 + 0.5;
            const intensity = 0.5 + pulse * 0.5;
            
            context.shadowColor = `rgba(0, 255, 204, ${intensity})`;
            context.shadowBlur = 30 * intensity;
            context.fillStyle = `rgba(0, 255, 204, ${0.8 + intensity * 0.2})`;
            
            context.save();
            context.translate(canvas.width / 2, canvas.height / 2);
            context.scale(0.8 + pulse * 0.4, 0.8 + pulse * 0.4);
            context.fillText(message, 0, 0);
            context.restore();
            
            context.shadowBlur = 0;
        }

        function renderWaveText(time) {
            const { canvas, context, message } = animationData;
            
            context.fillStyle = '#00ffcc';
            context.shadowColor = '#00ffcc';
            context.shadowBlur = 15;
            
            const letters = message.split('');
            const letterWidth = canvas.width / letters.length;
            
            letters.forEach((letter, i) => {
                const waveOffset = Math.sin(time + i * 0.5) * 20;
                const x = i * letterWidth + letterWidth / 2;
                const y = canvas.height / 2 + waveOffset;
                
                context.fillText(letter, x, y);
            });
            
            context.shadowBlur = 0;
        }

        function renderMatrixEffect(time) {
            const { canvas, context } = animationData;
            
            context.font = '16px monospace';
            context.fillStyle = '#00ffcc';
            
            const cols = Math.floor(canvas.width / 16);
            const rows = Math.floor(canvas.height / 20);
            
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    if (Math.random() < 0.05) {
                        const char = String.fromCharCode(Math.random() * 94 + 33);
                        const alpha = Math.random();
                        context.fillStyle = `rgba(0, 255, 204, ${alpha})`;
                        context.fillText(char, i * 16, j * 20);
                    }
                }
            }
            
            context.font = 'bold 28px Arial';
            context.fillStyle = 'rgba(0, 255, 204, 0.9)';
            context.shadowColor = '#00ffcc';
            context.shadowBlur = 10;
            context.textAlign = 'center';
            context.fillText('CONSISTENCY TEST', canvas.width / 2, canvas.height / 2);
            context.shadowBlur = 0;
        }

        // Test functions
        function checkTextContinuity(test) {
            const { canvas, context } = animationData;
            const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Check for horizontal text flow continuity
            const centerY = Math.floor(canvas.height / 2);
            const textRow = centerY * canvas.width * 4;
            
            let textPixels = [];
            for (let x = 0; x < canvas.width; x++) {
                const index = textRow + (x * 4);
                const brightness = data[index] + data[index + 1] + data[index + 2];
                textPixels.push(brightness > 50 ? 1 : 0);
            }
            
            // Find text segments
            let segments = [];
            let currentSegment = null;
            
            textPixels.forEach((pixel, x) => {
                if (pixel === 1) {
                    if (!currentSegment) {
                        currentSegment = { start: x, end: x };
                    } else {
                        currentSegment.end = x;
                    }
                } else if (currentSegment) {
                    segments.push(currentSegment);
                    currentSegment = null;
                }
            });
            
            if (currentSegment) segments.push(currentSegment);
            
            log(`Text segments found: ${segments.length}`, "info");
            
            if (segments.length === 1) {
                const segment = segments[0];
                const width = segment.end - segment.start;
                log(`✓ Single continuous text segment (width: ${width}px)`, "pass");
                testResults.push({ test: test.name, result: "PASS", details: "Text flows continuously" });
            } else if (segments.length > 1) {
                log(`⚠ Multiple text segments detected: ${segments.map(s => `${s.start}-${s.end}`).join(', ')}`, "warn");
                testResults.push({ test: test.name, result: "WARN", details: `${segments.length} text segments found` });
            } else {
                log(`✗ No text segments detected`, "fail");
                testResults.push({ test: test.name, result: "FAIL", details: "No text found" });
            }
        }

        function checkCharacterDistribution(test) {
            const { canvas, context } = animationData;
            const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Analyze character distribution across thirds
            const thirdWidth = canvas.width / 3;
            const leftThird = analyzeRegion(data, canvas.width, canvas.height, 0, thirdWidth);
            const middleThird = analyzeRegion(data, canvas.width, canvas.height, thirdWidth, 2 * thirdWidth);
            const rightThird = analyzeRegion(data, canvas.width, canvas.height, 2 * thirdWidth, canvas.width);
            
            const total = leftThird + middleThird + rightThird;
            
            if (total > 0) {
                const leftPct = (leftThird / total * 100).toFixed(1);
                const middlePct = (middleThird / total * 100).toFixed(1);
                const rightPct = (rightThird / total * 100).toFixed(1);
                
                log(`Character distribution - Left: ${leftPct}%, Middle: ${middlePct}%, Right: ${rightPct}%`, "info");
                
                // Check if distribution is reasonable (no section completely empty)
                if (leftThird > 0 && middleThird > 0 && rightThird > 0) {
                    log(`✓ Characters distributed across all sections`, "pass");
                    testResults.push({ test: test.name, result: "PASS", details: "Even character distribution" });
                } else {
                    log(`⚠ Uneven character distribution`, "warn");
                    testResults.push({ test: test.name, result: "WARN", details: "Uneven distribution" });
                }
            } else {
                log(`✗ No characters detected`, "fail");
                testResults.push({ test: test.name, result: "FAIL", details: "No characters found" });
            }
        }

        function checkUniformPulse(test) {
            const { canvas, context } = animationData;
            const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Check brightness consistency across horizontal center line
            const centerY = Math.floor(canvas.height / 2);
            const brightnesses = [];
            
            for (let x = 0; x < canvas.width; x += 10) { // Sample every 10 pixels
                const index = (centerY * canvas.width + x) * 4;
                const brightness = data[index] + data[index + 1] + data[index + 2];
                if (brightness > 20) { // Only consider non-black pixels
                    brightnesses.push(brightness);
                }
            }
            
            if (brightnesses.length > 2) {
                const avg = brightnesses.reduce((a, b) => a + b, 0) / brightnesses.length;
                const variance = brightnesses.reduce((sum, b) => sum + Math.pow(b - avg, 2), 0) / brightnesses.length;
                const stdDev = Math.sqrt(variance);
                const coefficient = stdDev / avg;
                
                log(`Brightness uniformity - Avg: ${avg.toFixed(1)}, StdDev: ${stdDev.toFixed(1)}, Coefficient: ${coefficient.toFixed(3)}`, "info");
                
                if (coefficient < 0.3) {
                    log(`✓ Uniform brightness across surface`, "pass");
                    testResults.push({ test: test.name, result: "PASS", details: "Uniform pulse scaling" });
                } else {
                    log(`⚠ Non-uniform brightness detected`, "warn");
                    testResults.push({ test: test.name, result: "WARN", details: "Uneven pulse scaling" });
                }
            } else {
                log(`✗ Insufficient brightness data`, "fail");
                testResults.push({ test: test.name, result: "FAIL", details: "No pulse detected" });
            }
        }

        function checkMatrixUniformity(test) {
            const { canvas, context } = animationData;
            const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Check matrix character distribution
            const leftHalf = analyzeRegion(data, canvas.width, canvas.height, 0, canvas.width / 2);
            const rightHalf = analyzeRegion(data, canvas.width, canvas.height, canvas.width / 2, canvas.width);
            
            const ratio = leftHalf > 0 ? rightHalf / leftHalf : 0;
            
            log(`Matrix distribution - Left: ${leftHalf}, Right: ${rightHalf}, Ratio: ${ratio.toFixed(2)}`, "info");
            
            if (ratio > 0.7 && ratio < 1.3) {
                log(`✓ Matrix effect distributed evenly`, "pass");
                testResults.push({ test: test.name, result: "PASS", details: "Even matrix distribution" });
            } else {
                log(`⚠ Uneven matrix distribution`, "warn");
                testResults.push({ test: test.name, result: "WARN", details: "Uneven matrix pattern" });
            }
        }

        function checkEdgeBoundaries(test) {
            const { canvas, context } = animationData;
            const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Check for artificial boundaries at quarter and center points
            const quarterX = Math.floor(canvas.width / 4);
            const centerX = Math.floor(canvas.width / 2);
            const threeQuarterX = Math.floor(3 * canvas.width / 4);
            
            let boundaries = 0;
            
            for (let y = canvas.height / 4; y < 3 * canvas.height / 4; y++) {
                // Check each boundary point
                [quarterX, centerX, threeQuarterX].forEach(x => {
                    const leftIndex = (y * canvas.width + (x - 1)) * 4;
                    const rightIndex = (y * canvas.width + (x + 1)) * 4;
                    
                    const leftBright = data[leftIndex] + data[leftIndex + 1] + data[leftIndex + 2];
                    const rightBright = data[rightIndex] + data[rightIndex + 1] + data[rightIndex + 2];
                    
                    if (Math.abs(leftBright - rightBright) > 200) {
                        boundaries++;
                    }
                });
            }
            
            log(`Edge boundaries detected: ${boundaries}`, "info");
            
            if (boundaries < 10) {
                log(`✓ No significant artificial boundaries`, "pass");
                testResults.push({ test: test.name, result: "PASS", details: "No artificial boundaries" });
            } else {
                log(`⚠ ${boundaries} potential boundaries detected`, "warn");
                testResults.push({ test: test.name, result: "WARN", details: `${boundaries} boundaries found` });
            }
        }

        function analyzeRegion(data, width, height, startX, endX) {
            let pixelCount = 0;
            
            for (let y = 0; y < height; y++) {
                for (let x = Math.floor(startX); x < Math.floor(endX); x++) {
                    const index = (y * width + x) * 4;
                    const brightness = data[index] + data[index + 1] + data[index + 2];
                    
                    if (brightness > 30) {
                        pixelCount++;
                    }
                }
            }
            
            return pixelCount;
        }

        function generateFinalReport() {
            log(`\n=== FINAL CONSISTENCY REPORT ===`, "summary");
            
            const passed = testResults.filter(r => r.result === "PASS").length;
            const warned = testResults.filter(r => r.result === "WARN").length;
            const failed = testResults.filter(r => r.result === "FAIL").length;
            
            log(`Total Tests: ${testResults.length}`, "summary");
            log(`Passed: ${passed} | Warnings: ${warned} | Failed: ${failed}`, "summary");
            
            testResults.forEach(result => {
                const type = result.result === "PASS" ? "pass" : 
                           result.result === "WARN" ? "warn" : "fail";
                log(`${result.test}: ${result.result} - ${result.details}`, type);
            });
            
            const overallScore = (passed / testResults.length) * 100;
            log(`\nOverall Consistency Score: ${overallScore.toFixed(1)}%`, "summary");
            
            if (overallScore >= 80) {
                log(`✓ CONCLUSION: Billboards appear to be functioning as unified surfaces`, "pass");
                log(`✓ No significant left/right consistency issues detected`, "pass");
            } else if (overallScore >= 60) {
                log(`⚠ CONCLUSION: Minor consistency issues detected but generally unified`, "warn");
            } else {
                log(`✗ CONCLUSION: Significant consistency issues detected`, "fail");
                log(`✗ Billboards may have left/right split behavior`, "fail");
            }
        }

        function setupEventListeners() {
            document.addEventListener('keydown', (event) => {
                switch(event.code) {
                    case 'Space':
                        event.preventDefault();
                        startTest((currentTestIndex + 1) % consistencyTests.length);
                        break;
                    case 'KeyR':
                        camera.position.set(0, 0, 8);
                        camera.lookAt(0, 0, 0);
                        log("Camera reset", "info");
                        break;
                    case 'KeyA':
                        // Auto-run all tests
                        testResults = [];
                        startTest(0);
                        break;
                }
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function log(message, type = "info") {
            const resultsDiv = document.getElementById('test-results');
            const resultElement = document.createElement('div');
            resultElement.className = `test-result ${type}`;
            resultElement.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
            resultsDiv.appendChild(resultElement);
            
            // Keep scrolled to bottom
            resultsDiv.scrollTop = resultsDiv.scrollHeight;
            
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            animationTime += 0.016;
            frameCount++;
            
            if (animationData) {
                renderBillboardContent();
            }
            
            renderer.render(scene, camera);
        }

        // Initialize
        init();
    </script>
</body>
</html>
