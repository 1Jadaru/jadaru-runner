<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Billboard Unified Surface Test</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #000;
            color: #00ffcc;
            font-family: Arial, sans-serif;
        }
        #info {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 100;
            color: #00ffcc;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            max-width: 400px;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #00ffcc;
            border-radius: 5px;
        }
        .test-result {
            margin: 10px 0;
            padding: 5px;
            border-left: 3px solid #00ff00;
            background: rgba(0, 255, 0, 0.1);
        }
        .test-warning {
            border-left-color: #ffaa00;
            background: rgba(255, 170, 0, 0.1);
        }
        .test-error {
            border-left-color: #ff0000;
            background: rgba(255, 0, 0, 0.1);
        }
    </style>
</head>
<body>
    <div id="info">
        <h3>Billboard Unified Surface Test</h3>
        <p>Testing whether billboards behave as unified surfaces rather than split left/right halves.</p>
        <div id="test-results"></div>
        <p><strong>Press SPACE</strong> to run next test</p>
        <p><strong>Press R</strong> to reset view</p>
        <p><strong>Press 1-4</strong> to test specific animation types</p>
    </div>
    
    <div id="container"></div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.158.0';
        
        // Test configuration
        const CONFIG = {
            BILLBOARD: {
                SCREEN_WIDTH: 512,
                SCREEN_HEIGHT: 256,
                PATTERN_TYPES: ['scrollText', 'pulse', 'wave', 'matrix'],
                MESSAGES: [
                    'UNIFIED SURFACE TEST - THIS TEXT SHOULD FLOW CONTINUOUSLY ACROSS THE ENTIRE BILLBOARD WIDTH',
                    'LEFT AND RIGHT HALVES SHOULD DISPLAY THE SAME CONTENT SEAMLESSLY',
                    'NO SPLIT OR DISCONTINUITY SHOULD BE VISIBLE IN THE MIDDLE',
                    'TESTING BILLBOARD CONSISTENCY AND TEXT CONTINUITY'
                ],
                TEXT_SCROLL_SPEED: 2,
                PULSE_SPEED: 2,
                FADE_SPEED: 1
            }
        };

        let scene, camera, renderer, billboard, animationData;
        let currentTest = 0;
        let testResults = [];
        let animationTime = 0;

        // Test scenarios
        const tests = [
            {
                name: "Long Text Scrolling Test",
                type: "scrollText", 
                message: "THIS IS A VERY LONG TEXT MESSAGE THAT SHOULD SCROLL CONTINUOUSLY ACROSS THE ENTIRE BILLBOARD WIDTH WITHOUT ANY BREAKS OR DISCONTINUITIES BETWEEN LEFT AND RIGHT HALVES - TESTING UNIFIED SURFACE BEHAVIOR",
                description: "Tests whether long scrolling text maintains continuity across full width"
            },
            {
                name: "Character-by-Character Wave Test",
                type: "wave",
                message: "ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890",
                description: "Tests whether wave animation affects each character consistently across the full width"
            },
            {
                name: "Pulse Scaling Test", 
                type: "pulse",
                message: "PULSE TEST - SCALING SHOULD BE UNIFORM ACROSS ENTIRE SURFACE",
                description: "Tests whether pulse scaling affects the entire billboard uniformly"
            },
            {
                name: "Matrix Overlay Test",
                type: "matrix",
                message: "MATRIX EFFECT TEST",
                description: "Tests whether matrix effect generates consistently across full surface"
            },
            {
                name: "Edge Transition Test",
                type: "scrollText",
                message: "EDGE>>>CENTER<<<EDGE - WATCH THE TRANSITION ZONES",
                description: "Tests specific transition behavior at potential split points"
            }
        ];

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000011);
            document.getElementById('container').appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 1.0);
            scene.add(ambientLight);

            // Create billboard
            createBillboard();
            
            // Position camera for optimal viewing
            camera.position.set(0, 0, 5);
            camera.lookAt(0, 0, 0);

            // Start first test
            runTest(0);
            
            // Animation loop
            animate();
            
            // Event listeners
            setupEventListeners();
            
            logTestResult("System initialized", "info");
        }

        function createBillboard() {
            const group = new THREE.Group();
            
            // Create frame (visible border)
            const frameGeometry = new THREE.BoxGeometry(3.4, 2.4, 0.1);
            const frameMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x333333,
                transparent: true,
                opacity: 0.8
            });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            group.add(frame);

            // Create screen with explicit UV mapping
            const screenGeometry = new THREE.PlaneGeometry(3.2, 2.2);
            
            // Explicit UV coordinates to ensure proper mapping
            const uvs = new Float32Array([
                0, 1,  // bottom-left
                1, 1,  // bottom-right  
                1, 0,  // top-right
                0, 0   // top-left
            ]);
            screenGeometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));

            // Create canvas texture
            const canvas = document.createElement('canvas');
            canvas.width = CONFIG.BILLBOARD.SCREEN_WIDTH;
            canvas.height = CONFIG.BILLBOARD.SCREEN_HEIGHT;
            const context = canvas.getContext('2d');
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.wrapS = THREE.ClampToEdgeWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;

            const screenMaterial = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                side: THREE.DoubleSide
            });

            const screen = new THREE.Mesh(screenGeometry, screenMaterial);
            screen.position.z = 0.06; // Slightly forward of frame
            group.add(screen);

            // Store animation data
            animationData = {
                screen,
                texture,
                canvas,
                context,
                material: screenMaterial,
                type: 'scrollText',
                phase: 0,
                message: 'TEST MESSAGE',
                scrollOffset: 0,
                lastUpdate: 0
            };

            billboard = group;
            scene.add(billboard);
            
            logTestResult("Billboard created with unified surface", "info");
        }

        function runTest(testIndex) {
            if (testIndex >= tests.length) {
                logTestResult("All tests completed!", "info");
                return;
            }

            currentTest = testIndex;
            const test = tests[testIndex];
            
            // Update animation data
            animationData.type = test.type;
            animationData.message = test.message;
            animationData.scrollOffset = 0;
            animationData.phase = Math.random() * Math.PI * 2;
            
            logTestResult(`Running Test ${testIndex + 1}: ${test.name}`, "info");
            logTestResult(`Description: ${test.description}`, "info");
            logTestResult(`Message: "${test.message}"`, "info");
            
            // Run test for 5 seconds, then automatically advance
            setTimeout(() => {
                analyzeTestResults(test);
                if (testIndex < tests.length - 1) {
                    setTimeout(() => runTest(testIndex + 1), 2000);
                }
            }, 5000);
        }

        function analyzeTestResults(test) {
            const { canvas, context } = animationData;
            
            // Sample pixel data from left, center, and right portions
            const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Check for consistency across horizontal bands
            const leftThird = analyzeRegion(data, canvas.width, 0, canvas.width / 3);
            const middleThird = analyzeRegion(data, canvas.width, canvas.width / 3, 2 * canvas.width / 3);
            const rightThird = analyzeRegion(data, canvas.width, 2 * canvas.width / 3, canvas.width);
            
            logTestResult(`${test.name} Analysis:`, "info");
            logTestResult(`Left third pixels: ${leftThird.nonBlackPixels}`, "info");
            logTestResult(`Middle third pixels: ${middleThird.nonBlackPixels}`, "info");
            logTestResult(`Right third pixels: ${rightThird.nonBlackPixels}`, "info");
            
            // Check for proper distribution
            const totalPixels = leftThird.nonBlackPixels + middleThird.nonBlackPixels + rightThird.nonBlackPixels;
            if (totalPixels > 0) {
                const leftRatio = leftThird.nonBlackPixels / totalPixels;
                const middleRatio = middleThird.nonBlackPixels / totalPixels;
                const rightRatio = rightThird.nonBlackPixels / totalPixels;
                
                logTestResult(`Distribution - Left: ${(leftRatio * 100).toFixed(1)}%, Middle: ${(middleRatio * 100).toFixed(1)}%, Right: ${(rightRatio * 100).toFixed(1)}%`, "info");
                
                // For scrolling text, we expect uneven distribution
                // For pulse/wave, we expect more even distribution
                if (test.type === 'scrollText') {
                    logTestResult("✓ Scrolling text shows expected pixel distribution", "success");
                } else if (test.type === 'pulse' || test.type === 'matrix') {
                    const evenness = 1 - Math.max(Math.abs(leftRatio - 0.33), Math.abs(middleRatio - 0.33), Math.abs(rightRatio - 0.33));
                    if (evenness > 0.7) {
                        logTestResult("✓ Content distributed evenly across surface", "success");
                    } else {
                        logTestResult("⚠ Uneven distribution detected", "warning");
                    }
                }
            } else {
                logTestResult("⚠ No content detected on billboard", "warning");
            }
            
            // Check for edge discontinuities
            const edgeDiscontinuities = checkEdgeDiscontinuities(data, canvas.width, canvas.height);
            if (edgeDiscontinuities < 5) {
                logTestResult("✓ No significant edge discontinuities detected", "success");
            } else {
                logTestResult(`⚠ ${edgeDiscontinuities} edge discontinuities detected`, "warning");
            }
        }

        function analyzeRegion(data, width, startX, endX) {
            let nonBlackPixels = 0;
            let totalPixels = 0;
            
            for (let y = 0; y < data.length / (width * 4); y++) {
                for (let x = Math.floor(startX); x < Math.floor(endX); x++) {
                    const index = (y * width + x) * 4;
                    const r = data[index];
                    const g = data[index + 1];
                    const b = data[index + 2];
                    
                    totalPixels++;
                    if (r > 10 || g > 10 || b > 10) {
                        nonBlackPixels++;
                    }
                }
            }
            
            return { nonBlackPixels, totalPixels };
        }

        function checkEdgeDiscontinuities(data, width, height) {
            let discontinuities = 0;
            const centerX = Math.floor(width / 2);
            
            // Check vertical line down the center for abrupt changes
            for (let y = 1; y < height - 1; y++) {
                const leftIndex = (y * width + (centerX - 1)) * 4;
                const rightIndex = (y * width + (centerX + 1)) * 4;
                
                const leftBrightness = data[leftIndex] + data[leftIndex + 1] + data[leftIndex + 2];
                const rightBrightness = data[rightIndex] + data[rightIndex + 1] + data[rightIndex + 2];
                
                const difference = Math.abs(leftBrightness - rightBrightness);
                if (difference > 100) { // Significant brightness difference
                    discontinuities++;
                }
            }
            
            return discontinuities;
        }

        function renderBillboardContent() {
            const { canvas, context, type, phase, message, texture } = animationData;
            const time = animationTime + phase;
            
            // Clear canvas
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = '#000011';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Set common properties
            context.font = 'bold 32px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            switch (type) {
                case 'scrollText':
                    renderScrollingText(time);
                    break;
                case 'pulse':
                    renderPulseText(time);
                    break;
                case 'wave':
                    renderWaveText(time);
                    break;
                case 'matrix':
                    renderMatrixEffect(time);
                    break;
            }
            
            // Update texture
            texture.needsUpdate = true;
            texture.version++;
        }

        function renderScrollingText(time) {
            const { canvas, context, message } = animationData;
            
            animationData.scrollOffset += CONFIG.BILLBOARD.TEXT_SCROLL_SPEED;
            if (animationData.scrollOffset > canvas.width + 200) {
                animationData.scrollOffset = -200;
            }
            
            context.shadowColor = '#00ffcc';
            context.shadowBlur = 20;
            context.fillStyle = '#00ffcc';
            
            context.fillText(message, animationData.scrollOffset, canvas.height / 2);
            context.shadowBlur = 0;
        }

        function renderPulseText(time) {
            const { canvas, context, message } = animationData;
            
            const pulse = Math.sin(time * CONFIG.BILLBOARD.PULSE_SPEED) * 0.5 + 0.5;
            const intensity = 0.5 + pulse * 0.5;
            
            context.shadowColor = `rgba(0, 255, 204, ${intensity})`;
            context.shadowBlur = 30 * intensity;
            context.fillStyle = `rgba(0, 255, 204, ${0.8 + intensity * 0.2})`;
            
            context.save();
            context.translate(canvas.width / 2, canvas.height / 2);
            context.scale(0.8 + pulse * 0.4, 0.8 + pulse * 0.4);
            context.fillText(message, 0, 0);
            context.restore();
            
            context.shadowBlur = 0;
        }

        function renderWaveText(time) {
            const { canvas, context, message } = animationData;
            
            context.fillStyle = '#00ffcc';
            context.shadowColor = '#00ffcc';
            context.shadowBlur = 15;
            
            const letters = message.split('');
            const letterWidth = canvas.width / letters.length;
            
            letters.forEach((letter, i) => {
                const waveOffset = Math.sin(time + i * 0.5) * 20;
                const x = i * letterWidth + letterWidth / 2;
                const y = canvas.height / 2 + waveOffset;
                
                context.fillText(letter, x, y);
            });
            
            context.shadowBlur = 0;
        }

        function renderMatrixEffect(time) {
            const { canvas, context } = animationData;
            
            context.font = '16px monospace';
            context.fillStyle = '#00ffcc';
            
            const cols = Math.floor(canvas.width / 16);
            const rows = Math.floor(canvas.height / 20);
            
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    if (Math.random() < 0.05) {
                        const char = String.fromCharCode(Math.random() * 94 + 33);
                        const alpha = Math.random();
                        context.fillStyle = `rgba(0, 255, 204, ${alpha})`;
                        context.fillText(char, i * 16, j * 20);
                    }
                }
            }
            
            // Add title overlay
            context.font = 'bold 28px Arial';
            context.fillStyle = 'rgba(0, 255, 204, 0.9)';
            context.shadowColor = '#00ffcc';
            context.shadowBlur = 10;
            context.textAlign = 'center';
            context.fillText('UNIFIED SURFACE', canvas.width / 2, canvas.height / 2);
            context.shadowBlur = 0;
        }

        function setupEventListeners() {
            document.addEventListener('keydown', (event) => {
                switch(event.code) {
                    case 'Space':
                        event.preventDefault();
                        runTest((currentTest + 1) % tests.length);
                        break;
                    case 'KeyR':
                        camera.position.set(0, 0, 5);
                        camera.lookAt(0, 0, 0);
                        logTestResult("Camera reset", "info");
                        break;
                    case 'Digit1':
                        runTest(0);
                        break;
                    case 'Digit2':
                        runTest(1);
                        break;
                    case 'Digit3':
                        runTest(2);
                        break;
                    case 'Digit4':
                        runTest(3);
                        break;
                }
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function logTestResult(message, type = "info") {
            const resultsDiv = document.getElementById('test-results');
            const resultElement = document.createElement('div');
            resultElement.className = `test-result test-${type}`;
            resultElement.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
            resultsDiv.appendChild(resultElement);
            
            // Keep only last 10 results
            while (resultsDiv.children.length > 10) {
                resultsDiv.removeChild(resultsDiv.firstChild);
            }
            
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            animationTime += 0.016; // Approximately 60fps
            
            if (animationData) {
                renderBillboardContent();
            }
            
            renderer.render(scene, camera);
        }

        // Initialize the test
        init();
    </script>
</body>
</html>
