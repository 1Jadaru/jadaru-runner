<!DOCTYPE html>
<html>
<head>
    <title>Billboard Fix Verification - Final</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: Arial, sans-serif; }
        canvas { display: block; }
        #status {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 5px;
            z-index: 100;
            max-width: 400px;
        }
        .success { color: #00ff00; }
        .error { color: #ff0000; }
        .info { color: #00ffcc; }
    </style>
</head>
<body>
    <div id="status">
        <h3>✅ Billboard Fix Verification</h3>
        <p><strong>Issue:</strong> Half billboard content missing</p>
        <p><strong>Solution:</strong> Explicit UV coordinate mapping</p>
        <div id="test-results"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000011);
        document.body.appendChild(renderer.domElement);

        // Replicate the exact fix from EnvironmentSystem
        function createFixedBillboard() {
            const group = new THREE.Group();
            
            // Frame
            const frameGeometry = new THREE.BoxGeometry(3.4, 2.4, 0.1);
            const frameMaterial = new THREE.MeshBasicMaterial({ color: 0x555555 });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.position.set(0, 2, -0.05);
            group.add(frame);
            
            // Create test canvas texture
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 256;
            const context = canvas.getContext('2d');
            
            // Clear background
            context.fillStyle = '#000011';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Create test pattern - should show FULL content
            context.fillStyle = '#ff0000';
            context.fillRect(0, 0, canvas.width/2, canvas.height);
            context.fillStyle = '#00ff00';
            context.fillRect(canvas.width/2, 0, canvas.width/2, canvas.height);
            
            // Add text to verify full display
            context.fillStyle = '#ffffff';
            context.font = 'bold 24px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText('LEFT HALF', canvas.width/4, canvas.height/2);
            context.fillText('RIGHT HALF', canvas.width*3/4, canvas.height/2);
            
            // Border to check edges
            context.strokeStyle = '#ffff00';
            context.lineWidth = 4;
            context.strokeRect(2, 2, canvas.width-4, canvas.height-4);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.generateMipmaps = false;
            texture.wrapS = THREE.ClampToEdgeWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.flipY = false;
            texture.needsUpdate = true;
            
            // APPLY THE FIX - Explicit UV coordinates
            const screenGeometry = new THREE.PlaneGeometry(3.2, 2.2);
            const uvs = new Float32Array([
                0, 1,  // bottom-left
                1, 1,  // bottom-right  
                1, 0,  // top-right
                0, 0   // top-left
            ]);
            screenGeometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
            
            const screenMaterial = new THREE.MeshBasicMaterial({
                map: texture,
                side: THREE.DoubleSide,
                transparent: false
            });

            const screen = new THREE.Mesh(screenGeometry, screenMaterial);
            screen.position.set(0, 2, 0);
            group.add(screen);
            
            return { group, texture, canvas, context };
        }

        // Create comparison - broken vs fixed
        const brokenBillboard = (() => {
            const group = new THREE.Group();
            
            // Create WITHOUT the UV fix (default PlaneGeometry)
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 256;
            const context = canvas.getContext('2d');
            
            context.fillStyle = '#000011';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = '#ff6600';
            context.fillRect(0, 0, canvas.width/2, canvas.height);
            context.fillStyle = '#0066ff';
            context.fillRect(canvas.width/2, 0, canvas.width/2, canvas.height);
            
            context.fillStyle = '#ffffff';
            context.font = 'bold 20px Arial';
            context.textAlign = 'center';
            context.fillText('BROKEN', canvas.width/4, canvas.height/2);
            context.fillText('VERSION', canvas.width*3/4, canvas.height/2);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.flipY = false;
            
            // Default PlaneGeometry (potentially broken UV)
            const screenGeometry = new THREE.PlaneGeometry(3.2, 2.2);
            const screenMaterial = new THREE.MeshBasicMaterial({ map: texture });
            const screen = new THREE.Mesh(screenGeometry, screenMaterial);
            screen.position.set(0, 2, 0);
            group.add(screen);
            
            return group;
        })();
        
        const fixedBillboard = createFixedBillboard();
        
        // Position billboards side by side
        brokenBillboard.position.set(-4, 0, -6);
        fixedBillboard.group.position.set(4, 0, -6);
        
        scene.add(brokenBillboard);
        scene.add(fixedBillboard.group);
        
        // Add labels
        function addLabel(text, position, color = '#ffffff') {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            
            context.fillStyle = '#000';
            context.fillRect(0, 0, 256, 64);
            context.fillStyle = color;
            context.font = 'bold 16px Arial';
            context.textAlign = 'center';
            context.fillText(text, 128, 32);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({ map: texture });
            const geometry = new THREE.PlaneGeometry(2.5, 0.6);
            const label = new THREE.Mesh(geometry, material);
            label.position.copy(position);
            label.position.y = -0.5;
            scene.add(label);
        }
        
        addLabel('BEFORE FIX', new THREE.Vector3(-4, 0, -6), '#ff6600');
        addLabel('AFTER FIX', new THREE.Vector3(4, 0, -6), '#00ff00');
        
        // Position camera to see both
        camera.position.set(0, 2, 0);
        camera.lookAt(0, 2, -6);

        // Test results display
        const testResults = document.getElementById('test-results');
        
        let frameCount = 0;
        function animate() {
            requestAnimationFrame(animate);
            frameCount++;
            
            // Update status every 60 frames
            if (frameCount % 60 === 0) {
                testResults.innerHTML = `
                    <div class="info"><strong>Frame:</strong> ${frameCount}</div>
                    <div class="success"><strong>✅ Fix Applied:</strong> Explicit UV coordinates</div>
                    <div class="info"><strong>Expected Result:</strong></div>
                    <ul>
                        <li>LEFT: May show partial content (default UV)</li>
                        <li>RIGHT: Should show FULL content (fixed UV)</li>
                    </ul>
                    <div class="success"><strong>UV Fix:</strong></div>
                    <code>
                    const uvs = new Float32Array([<br>
                    &nbsp;&nbsp;0, 1, // bottom-left<br>
                    &nbsp;&nbsp;1, 1, // bottom-right<br>
                    &nbsp;&nbsp;1, 0, // top-right<br>
                    &nbsp;&nbsp;0, 0  // top-left<br>
                    ]);
                    </code>
                `;
            }
            
            renderer.render(scene, camera);
        }

        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
